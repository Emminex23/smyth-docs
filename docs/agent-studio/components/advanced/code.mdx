---
title: Code
description: Learn how to use the Code component to write and execute JavaScript directly in your agent workflows. Add custom logic, transform inputs, and handle outputs without external services.
keywords: [JavaScript, Code component, custom logic, inputs, outputs, error handling, debugging, data processing, workflows, SaaS automation]
toc_max_heading_level: 2
---

# Code Component

The Code component lets you add custom logic to your workflows with plain JavaScript. Use it to transform inputs, validate content, handle errors, or run lightweight processing without relying on external APIs or servers.

<InfoCallout title="Why this matters">
When built-in components aren’t flexible enough, the Code component gives you the power to calculate, filter, or transform data inline. It’s ideal for handling edge cases, quick validations, or lightweight processing logic.
</InfoCallout>

<Arcade
  src="https://demo.arcade.software/HbTFpYUtUTtU3ZpafjWU?embed&embed_mobile=tab&embed_desktop=inline&show_copy_link=true"
  title="Code | SmythOS"
/>

<Spacer size="md" />

## Step 1: Understand Inputs and Outputs

Every Code block works with **three types of variables**:

| Type              | Prefix          | Description                                                                                     |
|-------------------|-----------------|-------------------------------------------------------------------------------------------------|
| **Input**         | `_<inputName>`  | Read-only variable for each input you define. Defaults are `A` and `B`.                         |
| **Output**        | `_output`       | Required variable for your final result. Can be a primitive or a JSON object.                   |
| **Error**         | `_error`        | Optional variable. Assign a JSON object to safely signal errors downstream.                     |

<TipCallout title="Best Practice">
Give inputs clear, descriptive names like `orderTotal` or `customerName`.  
In code, they appear as `_orderTotal` or `_customerName`.  
This makes your logic easier to read and debug.
</TipCallout>

<Spacer size="md" />

## Step 2: Write Your Code

At minimum, your script must set `_output`.  

### Simplest Example: Hello World
```javascript
_output = "Hello World!";
```

### Example: Add Two Numbers
With default inputs `A` and `B`:  

```javascript
const _A = {{A}};
const _B = {{B}};

_output = _A + _B;
```

<Spacer size="md" />

## Step 3: Add Inputs

You can add more inputs beyond `A` and `B`:

1. Open the **Inputs** tab.  
2. Click **+ Add Input**.  
3. Name it (e.g. `purchaseTotal`, `taxRate`).  

Each input becomes available in your code with an underscore prefix:  

```javascript
const _purchaseTotal = {{purchaseTotal}};
const _taxRate = {{taxRate}};

const total = _purchaseTotal * (1 + _taxRate);

_output = { total };
```

<Spacer size="md" />

## Step 4: Configure Outputs

Your script must always set `_output`.  
If you assign an object, you can expose specific fields as **custom outputs** for downstream use.  

```javascript
_output = {
  total: 50,
  status: "OK"
};
```

Now both `total` and `status` are available to later components.  

<Spacer size="md" />

## Step 5: Handle Errors Gracefully

Instead of breaking your workflow, use `_error` to signal problems.  
This allows retries, fallback steps, or notifications instead of a hard stop.  

### Example: Missing Input
```javascript
if (!_customerName) {
  _error = {
    message: "Missing input: customerName",
    context: { provided: _customerName }
  };
}
```

<InfoCallout title="Why use _error?">
Assigning a structured error ensures your workflow continues safely.  
Downstream components can decide what to do next.
</InfoCallout>

<Spacer size="md" />

## Advanced Usage

### Example: Parse CSV from URL

A common real-world scenario:  

1. Capture a `csvUrl` input.  
2. Use an [API Call](/docs/agent-studio/components/advanced/api-call) to fetch the CSV file.  
3. Parse the data with a Code block:  

```javascript
const _csvText = _apiResponse;
const lines = _csvText.split('\\n').filter(line => line.trim() !== '');
const headers = lines[0].split(',').map(h => h.trim());

const data = lines.slice(1).map(line => {
  const values = line.split(',').map(v => v.trim());
  return headers.reduce((row, header, i) => {
    row[header] = values[i] || '';
    return row;
  }, {});
});

_output = {
  success: true,
  data,
  summary: { totalRows: data.length, headers }
};
```

This structured JSON can be used directly by components like **GenAI LLM**, **RAG Remember**, or another Code block.  

<Spacer size="md" />

## Best Practices

Keep your Code blocks clean, reliable, and easy to maintain:  

- **Always set `_output`** – every script must assign a value.  
- **Use `_error`** – report failures in structured form.  
- **Name inputs clearly** – use camelCase, not single letters.  
- **Validate inputs early** – catch missing/invalid values upfront.  
- **Use multiple Code blocks** – avoid one giant script.  
- **Debug with `console.log()`** – inspect values in the Logs tab.  
- **Stay under 5 MB per input** – split or preprocess larger data.  
- **Comment your code** – explain logic for future maintainers.  

<Spacer size="md" />

## What’s Next

Now that you know how to use the Code component:  

- Connect outputs to **[GenAI LLM](/docs/agent-studio/components/base/gen-ai-llm)** for summaries or insights.  
- Store structured data using **[RAG Remember](/docs/agent-studio/components/rag-data/rag-remember)**.  
- Combine Code with an **[API Call](/docs/agent-studio/components/advanced/api-call)** to fetch and process external data.  
- Wrap custom code into a reusable **[Agent Skill](/docs/agent-studio/components/base/agent-skill)**.  
- Scale logic with multiple Code blocks across your workflow.  
