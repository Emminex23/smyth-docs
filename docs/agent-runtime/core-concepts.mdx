---
title: Core Concepts
description: Understand the key building blocks of the Smyth Runtime Environment (SRE) and how they power agent execution, resource management, and extensibility.
keywords: [SmythOS, SRE, runtime, components, subsystems, architecture, agents]
sidebar_position: 4
toc_max_heading_level: 2
---

# Core Concepts of SRE

Smyth Runtime Environment (SRE) is the **operating system for AI agents** in SmythOS.  
Like any good OS, it hides infrastructure complexity behind clear abstractions so you can focus on intelligence, not plumbing.  
To make that possible, SRE splits runtime responsibilities into modular subsystems, enforces zero-trust execution with the Candidate / ACL model, and exposes pluggable connectors for any data store, LLM, or API.

<InfoCallout title="Why these concepts matter">
Mastering SRE’s core building blocks—subsystems, connectors, and the Candidate / ACL security layer—lets you:

- **Ship faster** – mix-and-match components without rewriting business logic.  
- **Stay secure** – every run inherits least-privilege permissions by design.  
- **Scale up** – swap local services for cloud equivalents with a config change.  
- **Debug confidently** – per-component logs and traces surface every step of execution.
</InfoCallout>

<Spacer size="md" />

## What is the runtime environment?

The runtime is the system your agents run on. It handles their execution lifecycle, enforces resource boundaries, integrates external services, and manages data, logs, and state.

Unlike typical serverless or container runtimes, SRE is designed for **AI agent workloads**. This means it’s optimized for:

- Prompt and response handling
- Streaming and chat interactions
- Skills and tool calling
- LLM routing and caching

<Spacer size="md" />

## Modular by design

SRE is built as a modular runtime kernel, as detailed in the [Architecture overview](/docs/agent-runtime/architecture). The runtime is divided into primary **subsystems**, and services within them—like storage, caching, or logging—are accessed through `connectors`. This gives you full control over how data and logic flow through your system.

You can swap underlying implementations (e.g., from local storage to S3) without changing your agent's business logic.

| Core Subsystem | Purpose | Examples of Services & Connectors |
| :--- | :--- | :--- |
| **IO Subsystem** | Handles all input and output operations. | `Storage`, `VectorDB`, `Log`, `Router`, `NKV`, `CLI` |
| **LLM Manager** | Manages all interactions with AI models. | `OpenAI`, `Anthropic`, Caching, Token Tracking|
| **Security** | Manages secrets, identity, and access control. | `Vault`, `Account Management`, ACLs |
| **Memory Manager** | Manages agent state, context, and cache. | `Cache Service` (RAM, Redis), LLM Context History|
| **Agent Manager** | Orchestrates agent execution and lifecycle. | Component Workflows, SSE Streaming |

<TipCallout title="Unified service layer">
This architecture ensures a clean separation of concerns. You can configure infrastructure through connectors without touching your agent's core logic.
</TipCallout>
<Spacer size="md" />

## The Candidate system

Every time an agent runs, it does so as a `Candidate`—a lightweight, isolated compute context. Each `Candidate` has its own permissions, memory, and logging space, governed by the [Security Model](/docs/agent-runtime/security).

This isolation ensures:

- You can set access control per agent or task
- Resource usage is scoped to a single run
- Agents cannot interfere with each other

```typescript
const candidate = AccessCandidate.agent(agentId);
const storage = ConnectorService.getStorageConnector().user(candidate);
await storage.write('results.json', output);
```

<Spacer size="md" />

## Agents and components

Agents in SRE are made of connected `components`. Each component performs a specific operation—like calling an LLM, fetching data, or executing logic.

You can build agent workflows visually in **[Smyth Studio](/docs/agent-studio/overview)** or programmatically using the **[SDK](/docs/agent-runtime/sdk-guide)**.

Agent structure:

<pre>
┌────────────────────────────┐
│       Agent Process        │ ← Your AI Agent
├────────────────────────────┤
│       Component A          │ ← Prompt to LLM
├────────────────────────────┤
│       Component B          │ ← Data processing
├────────────────────────────┤
│       Component C          │ ← API call
└────────────────────────────┘
</pre>

Each component has defined inputs, outputs, and runtime settings. They stream data to each other and can be reused across agents.

<Spacer size="md" />

## Execution lifecycle

SRE manages the full lifecycle of agent execution:

1.  **Boot:** Loads config and connectors
2.  **Authenticate:** Validates user or system identity
3.  **Schedule:** Allocates compute resources
4.  **Execute:** Runs the agent logic with access control
5.  **Stream:** Emits logs, outputs, and events in real time
6.  **Tear down:** Frees memory and logs trace info

This model supports both **single-shot prompts** and **long-lived agent sessions** with chat history.

<Spacer size="md" />

## Logging

Every action in SRE can be logged and traced, with support for:

- Component-level execution traces
- SSE (server-sent events) streaming
- External observability tools
- Replay of agent runs in **Studio**

```typescript
const logs = await connector.getLogStream({ candidate });
logs.on('entry', (line) => {
  console.log('[trace]', line);
});
```

<WarningCallout title="Trace visibility depends on connector">
Some log features—like structure or streaming—depend on your `Log` connector (e.g. `Smyth` vs `Console`).
</WarningCallout>

<Spacer size="md" />

## Security model

SRE follows a strict **[access-controlled runtime model](/docs/agent-runtime/security)**:

- Every resource access is gated by ACLs
- Secrets are managed via Vault connectors
- Agents cannot access unauthorized subsystems
- Admins can set per-run access policies

Use the `AccessCandidate` object to scope calls to the agent's identity.

<TipCallout title="Principle of least privilege">
Always grant only the minimum permissions an agent needs. This improves safety and traceability.
</TipCallout>

<Spacer size="md" />

## When to use API vs SDK

The runtime APIs give you fine-grained control. The **[SDK](/docs/agent-runtime/sdk-guide)** provides a higher-level abstraction for building and wiring agents. You can choose based on your needs.

| Use case | Use the SDK | Use Runtime API |
|---|---|---|
| Fast prototyping | <Badge type="required" /> Yes | |
| Controlled infrastructure setup | | <Badge type="required" /> Yes |
| Type-safe component wiring | <Badge type="required" /> Yes | |
| System-level debugging and tracing | | <Badge type="required" /> Yes |
| Custom connector configuration | | <Badge type="required" /> Yes |
| Business logic only | <Badge type="required" /> Yes | |

<Spacer size="md" />

## What's Next?

- **[Quickstart](/docs/agent-runtime/quickstart)** – Try building your first agent
- **[Deployment options](/docs/agent-runtime/deployment)** – How to run agents locally or in production
- **[SDK Guide](/docs/agent-runtime/sdk-guide)** – Programmatically define agent logic
- **[Component Reference](/docs/agent-runtime/components)** – Use and connect runtime modules