---
title: Quickstart
sidebar_label: Quickstart
description: A fast, full example for creating, prompting, and wiring up agents using the Smyth SDK.
keywords: [SmythOS, SRE, SDK, agent creation, AI agents, TypeScript, programming]
sidebar_position: 3
---

# Quickstart with SRE

<InfoCallout title="What you'll learn">
Build your first real AI agent with behavior, skills, and prompt flow using the Smyth SDK.
</InfoCallout>

<Spacer size="md" />

## Prerequisite

Before starting, make sure you’ve installed and initialized the Smyth Runtime.

If you haven’t done that yet, head to [Getting Started with SRE](/docs/agent-runtime/getting-started) first.

<Spacer size="md" />

## Step 1: Create your first agent

Start by defining your agent’s name, model, and role in the conversation.

```typescript
const agent = new SDK.Agent({
  name: 'QuickSupportBot',
  model: 'gpt-4',
  behavior: 'You are a helpful assistant for software troubleshooting.',
});
```

## Step 2: Add a custom skill

Skills are reusable functions your agent can call. Here’s one to summarize user issues:

```typescript
agent.addSkill({
  name: 'summarizeIssue',
  description: 'Summarizes a user support message',
  process: async (input) => {
    return { summary: `Issue: ${input}` };
  },
});
```

## Step 3: Prompt the agent

Now try prompting the agent directly and print the result. This is a simple one-shot interaction.

```typescript
const response = await agent.prompt('My screen flickers when I open the app.');
console.log(response);
```

## Step 4: Use chat mode (optional)
You can use a persistent chat to maintain conversational context across turns.

```typescript
const chat = agent.chat();

await chat.send('I’m having trouble logging in.');
await chat.send('It only happens on mobile.');
console.log(chat.history);
```

## Step 5: Linking components to build workflows

You can build simple workflows by connecting modular components.
```typescript
const llm = SDK.GenAILLM({ model: 'gpt-4' }, agent);
const classifier = SDK.Classifier({ classes: ['bug', 'feature request', 'other'] }, agent);

classifier.in({ Input: llm.out.Reply });
```
This setup takes the LLM’s reply and sends it into a classifier, which is useful for routing or tagging tasks.

<InfoCallout title="Why this works"> The SDK handles input/output wiring between components automatically. </InfoCallout>
<Spacer size="md" />

## You now have a real agent

That's it! You’ve just built an actual agent that:

- Understands task-specific prompts
- Can hold context in conversations
- Has pluggable skills
- Can wire up components into flows

<Spacer size="md" />

## What’s next?

- [Learn how SRE works under the hood](/docs/agent-runtime/overview)
- [Export your agent and share it](/docs/agent-collaboration/overview)
- [Build visual workflows in Studio](/docs/agent-studio/overview)
