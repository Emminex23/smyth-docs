---
title: SRE Architecture
sidebar_label: Architecture
description: Learn how SmythOS's Runtime Environment works behind the scenes to run your AI agents efficiently and securely.
keywords: [SmythOS, SRE, architecture, subsystems, modular, AI agents, runtime, storage, LLM, security]
sidebar_position: 2
toc_max_heading_level: 2
---

# SRE Architecture

The [Smyth Runtime Environment (SRE)](/docs/agent-runtime/overview) is the operating system for AI agents within **SmythOS**. It gives you a secure, modular runtime that handles infrastructure, security, memory, and orchestration—so you can focus entirely on building intelligent agents.

You can build on SRE however you like:
- Use **Studio** to drag, drop, and connect components and visually build agents.
- Use the **[Smyth SDK](/docs/agent-runtime/sdk-guide)** for full programmatic control.
- Combine both in [hybrid workflows](/docs/agent-runtime/hybrid-workflows) that balance visual design and code.

<InfoCallout title="Why this architecture matters">
SRE ensures your agents run reliably and securely. It turns infrastructure concerns into pluggable subsystems that you don’t need to rebuild from scratch.
</InfoCallout>
<Image src="/img/sre/sre-diagram.png" alt="Smyth Runtime Architecture Diagram" caption="SRE is composed of modular subsystems that work together to run your agents" />

Each colored section in the diagram above is a subsystem, and each is responsible for a specific layer of agent execution, from permissions to storage to AI integration.

<Divider />

## How SRE organizes your AI agent’s runtime
SRE takes inspiration from operating systems to provide a reliable and secure runtime platform for AI agents. Instead of managing low-level complexity yourself, SRE abstracts and handles key responsibilities behind the scenes.

It’s designed for real-world, production-ready agents that integrate deeply into your workflows, APIs, and systems. It breaks these responsibilities into modular **subsystems**, each focused on a specific task. This makes the system easier to reason about, extend, and scale.

Each subsystem handles a specific class of responsibility:

- **Secure access** to APIs, data sources, and third-party tools
- **Smart routing** and caching for AI model interactions
- **Secret management** and fine-grained access control
- **Agent memory** to track conversations and state
- **Workflow orchestration** for coordinating internal components
- **Reusable components** to accelerate development

This separation of concerns mirrors OS principles like process isolation, memory management, and inter-process communication, but applied to autonomous AI agents.

## SRE Subsystems Overview

SRE is made up of modular subsystems. Each subsystem focuses on its domain and interacts cleanly with the others. This separation makes your agents more reliable and easier to troubleshoot.

Here’s a quick look at what each one handles:

| **Subsystem** | **What it does** |
|---|---|
| [**IO**](#handle-data--apis) | Handles data input/output, storage, API routing, and logging via connectors. |
| [**LLM Manager**](#run-ai-calls) | Interfaces with AI providers; includes caching and usage tracking. |
| [**Security**](#secure-your-agents) | Manages secrets, authentication, and access control. |
| [**Memory Manager**](#manage-agent-memory) | Tracks agent context, conversation state, and multi-layer caching. |
| [**Agent Manager**](#orchestrate-agent-execution) | Runs and coordinates agent components; manages execution lifecycle and streaming. |
| [**Components**](#use-built-in-components) | Provides 40+ reusable building blocks for logic, data, APIs, and model interaction. |

## Handle data & APIs
Your agent needs to read and write data, log its actions, call APIs, and expose endpoints. The **IO subsystem** handles all this.

It supports multiple connectors so you can choose what fits your use case:

| Service | What it does | Connectors available |
|---|---|---|
| **Storage** | Save and retrieve files | Local filesystem, S3, Smyth |
| **VectorDB** | Store and query vectors | Pinecone, SmythManaged |
| **Log** | Track activity and errors | Console, Smyth |
| **Router** | Serve HTTP APIs | Express |
| **NKV** | Fast key-value storage | Redis |
| **CLI** | Command line interface | CLI |

```typescript
// Switch storage providers with only a configuration change
const localStorage = ConnectorService.getConnector('Storage', 'Local');
const s3Storage = ConnectorService.getConnector('Storage', 'S3');
```

<TipCallout title="Pro tip">
Switching storage providers requires zero code changes. Your agents stay consistent even when your backend evolves.
</TipCallout>

## Run AI calls
Your agent’s intelligence depends on AI models. The **LLM Manager subsystem** gives you a unified way to call multiple providers like OpenAI, Anthropic, and Google AI.

It does more than just route requests:

- It caches results to reduce latency and costs.
- Tracks token usage for monitoring.
- Lets you configure custom models easily.

```typescript
// Use multiple LLM providers in the same agent
const openai = ConnectorService.getLLMConnector('OpenAI');
const claude = ConnectorService.getLLMConnector('Anthropic');
```

## Secure your agents
Security is baked into the runtime. The **[Security subsystem](/docs/agent-runtime/security)** manages sensitive credentials and permissions.

You get:

- Encrypted vault storage for API keys and tokens via connectors like HashiCorp Vault.
- Pluggable account management for enterprise-grade authentication.
- Role-based access control so you decide who can do what.
- Detailed audit logs to track all operations.

<WarningCallout title="Security reminder">
Never store production secrets in local files. Use cloud vault connectors for safety.
</WarningCallout>
This subsystem makes sure your secrets never leak and your agents run with least privilege.

## Manage agent memory
Agents aren’t stateless. They need memory. The **Memory Manager subsystem** handles:

- Multi-layer caching (RAM, Redis, S3) for speed and durability.
- Runtime context that tracks agent state and conversation history.
- Performance metrics to optimize memory use.
- Resource monitoring

<InfoCallout title="Did you know?">
Efficient memory management helps your agents respond faster and reduces costly repeated API calls.
</InfoCallout>

By managing state efficiently, your agents respond consistently and fast.

## Orchestrate agent execution
Your agent runs as a collection of components working together. The **Agent Manager subsystem** coordinates them all.

It handles:

- Agent lifecycle events: starting, pausing, resuming, and stopping.
- Real-time monitoring of performance and logs.
- Asynchronous, non-blocking execution for smooth multitasking.
- Streaming live updates to connected clients via Server-Sent Events.

```typescript
┌─────────────────┐
│  Agent Process  │ ← Your AI agent runs here
├─────────────────┤
│  Component A    │ ← Calls AI models
├─────────────────┤
│  Component B    │ ← Processes data
├─────────────────┤
│  Component C    │ ← Calls external APIs
└─────────────────┘
```

## Use Built-in Components
SRE includes 40+ production-ready [Components](/docs/agent-runtime/components) that accelerate your development.

Some key examples:

- `GenAILLM` — Language model integration
- `VisionLLM` — Image understanding
- `APICall` — HTTP requests with OAuth
- `DataSourceIndexer` — Document indexing
- `LogicAND` — Boolean logic
- `FileStore` — File operations

<InfoCallout title="Explore more">
For the full list, see the [Components Reference](/docs/agent-runtime/components) page.
</InfoCallout>

## What’s Next?
Explore more to master your AI agent’s runtime:

- **[Getting Started](/docs/agent-runtime/quickstart)**: Run your first agent.
- **[Building Agents](/docs/agent-runtime/building-agents)**: Create an agent from scratch.
- **[Smyth SDK Guide](/docs/agent-runtime/sdk-guide)**: Program your agents with the SDK.